apiVersion: v1
data:
  README.md: "The following is a summary of the templates defined in this directory:\n\n###
    bird.toml.template / bird6.toml.tempate\n\nReferenced by bird.toml.toml and bird6.toml.toml.\n\nThese
    templates write out a TOML file (bird.toml and bird6.toml) that is used \nto tell
    confd which set of the main BIRD templates to use.\n\nBased off the node_mesh
    parameter, the TOML file generated either points to the\nfull-mesh config files,
    or the no-mesh config files.\n\nOnce confd writes out the appropriate TOML file,
    confd is restarted to pick up\nthe change to the bird.toml and bird6.toml files.
    \ Since there are two sets\nof changes, a change to the node_mesh parameter will
    result in a double\nrestart of confd.\n\nIn short, this is used by confd to generate
    its own configuration.\n\n\n### bird_ipam.cfg.template / bird6_ipam.cfg.template\n\nReferenced
    by bird_ipam.toml and bird6_ipam.toml.\n\nThese templates write out the route
    filters based on IPAM configuration.  This\nis inherited by the main BIRD configuration
    file.\n\nIt is separated out from the main BIRD configuration file because it
    watches a\ndifferent sub-tree in etcd.  This allows confd to watch a smaller portion
    of \nthe tree to reduce churn.\n\n\n### bird.cfg.mesh.template / bird6.cfg.mesh.template\n\nReferenced
    by the confd-generated bird.toml and bird6.toml files.\n\nThese templates write
    out the main BIRD configuration when the full \nnode-to-node mesh is enabled.\n\n\n###
    bird.cfg.no-mesh.template / bird6.cfg.no-mesh.template\n\nReferenced by the confd-generated
    bird.toml and bird6.toml files.\n\nThese templates write out the main BIRD configuration
    when the full \nnode-to-node mesh is disabled.\n[![Analytics](https://calico-ga-beacon.appspot.com/UA-52125893-3/calicoctl/calico_node/filesystem/templates/README.md?pixel)](https://github.com/igrigorik/ga-beacon)\n"
  bird.cfg.no-mesh.template: |
    # Generated by confd
    include "bird_aggr.cfg";
    include "custom_filters.cfg";
    include "bird_ipam.cfg";
    {{$node_ip_key := printf "/host/%s/ip_addr_v4" (getenv "NODENAME")}}{{$node_ip := getv $node_ip_key}}
    {{$node_network_key := printf "/host/%s/network_v4" (getenv "NODENAME")}}{{$node_network := getv $node_network_key}}
    {{$node_reflector_key := printf "/host/%s/reflector" (getenv "NODENAME")}}{{$node_reflector := getv $node_reflector_key}}

    router id {{$node_ip}};

    {{define "LOGGING"}}
    {{$node_logging_key := printf "/host/%s/loglevel" (getenv "NODENAME")}}{{if exists $node_logging_key}}{{$logging := getv $node_logging_key}}
    {{if eq $logging "debug"}}  debug all;{{else if ne $logging "none"}}  debug { states };{{end}}
    {{else if exists "/global/loglevel"}}{{$logging := getv "/global/loglevel"}}
    {{if eq $logging "debug"}}  debug all;{{else if ne $logging "none"}}  debug { states };{{end}}
    {{else}}  debug { states };{{end}}
    {{end}}

    # Configure synchronization between routing tables and kernel.
    protocol kernel {
      learn;             # Learn all alien routes from the kernel
      persist;           # Don't remove routes on bird shutdown
      scan time 2;       # Scan kernel routing table every 2 seconds
      import all;
      export filter calico_ipip; # Default is export none
      graceful restart;  # Turn on graceful restart to reduce potential flaps in
                         # routes when reloading BIRD configuration.  With a full
                         # automatic mesh, there is no way to prevent BGP from
                         # flapping since multiple nodes update their BGP
                         # configuration at the same time, GR is not guaranteed to
                         # work correctly in this scenario.
    }

    # Watch interface up/down events.
    protocol device {
      {{template "LOGGING"}}
      scan time 2;    # Scan interfaces every 2 seconds
    }

    protocol direct {
      {{template "LOGGING"}}
      interface -"cali*", "*"; # Exclude cali* but include everything else.
    }

    {{$node_as_key := printf "/host/%s/as_num" (getenv "NODENAME")}}
    # Template for all BGP clients
    template bgp bgp_template {
      {{template "LOGGING"}}
      description "Connection to BGP peer";
      local as {{if exists $node_as_key}}{{getv $node_as_key}}{{else}}{{getv "/global/as_num"}}{{end}};
      import all;        # Import all routes, since we don't know what the upstream
                         # topology is and therefore have to trust the ToR/RR.
      export filter calico_pools;  # Only want to export routes for workloads.

      add paths on;
      graceful restart;  # See comment in kernel section about graceful restart.

      multihop;
    }
    # ----------- Subnet Reflectors ----------

    {{if eq $node_reflector "subnet"}} # This node is a reflector!

    # -- Peer with non-reflectors in this subnet ---

    {{range $host := lsdir "/subnet/host"}}
    {{$onode_as_key := printf "/subnet/host/%s/as_num" .}}
    {{$onode_ip := getv (printf "/subnet/host/%s/ip_addr_v4" .)}}
    {{$onode_network := getv (printf "/subnet/host/%s/network_v4" .)}}
    {{$onode_reflector := getv (printf "/subnet/host/%s/reflector" .)}}
    {{$nums := split $onode_ip "."}}{{$id := join $nums "_"}}
    # For peer {{(printf "/subnet/host/%s/ip_addr_v4" .)}}
    {{if eq $onode_ip ($node_ip) }}# Skipping ourselves ({{$onode_ip}})
    {{else if eq $onode_reflector "subnet"}}# Skipping co-subnet reflector {{$onode_ip}}
    {{else if ne "" $onode_ip}}protocol bgp SubnetReflector_{{$id}} from bgp_template {
      neighbor {{$onode_ip}} as {{if exists $onode_as_key}}{{getv $onode_as_key}}{{else}}{{getv "/global/as_num"}}{{end}};
      source address {{$node_ip}};
      rr client;
      rr cluster id {{index (split $node_network "/") 0}};
      next hop keep;
    }{{end}}{{end}}

    # --- Peer with all other reflectors ---

    {{range $host := lsdir "/reflector/host"}}
    {{$onode_as_key := printf "/reflector/host/%s/as_num" .}}
    {{$onode_ip := getv (printf "/reflector/host/%s/ip_addr_v4" .)}}
    {{$onode_network := getv (printf "/reflector/host/%s/network_v4" .)}}
    {{$nums := split $onode_ip "."}}{{$id := join $nums "_"}}
    # For peer {{(printf "/subnet/host/%s/ip_addr_v4" .)}}
    {{if eq $onode_ip ($node_ip) }}# Skipping ourselves ({{$node_ip}})
    {{else if ne "" $onode_ip}}protocol bgp SubnetReflectorMesh_{{$id}} from bgp_template {
      neighbor {{$onode_ip}} as {{if exists $onode_as_key}}{{getv $onode_as_key}}{{else}}{{getv "/global/as_num"}}{{end}};
      source address {{$node_ip}};
      rr cluster id {{index (split $node_network "/") 0}};
      next hop keep;
    }{{end}}{{end}}

    {{else}} # This node is not a reflector

    # --- Peer with reflectors in this subnet  ---

    {{range $host := lsdir "/subnet/reflector/host"}}
    {{$onode_as_key := printf "/subnet/reflector/host/%s/as_num" .}}
    {{$onode_ip := getv (printf "/subnet/reflector/host/%s/ip_addr_v4" .)}}
    {{$onode_network := getv (printf "/subnet/reflector/host/%s/network_v4" .)}}
    {{$nums := split $onode_ip "."}}{{$id := join $nums "_"}}
    # For peer {{(printf "/subnet/host/%s/ip_addr_v4" .)}}
    {{if eq $onode_ip ($node_ip) }}# Skipping ourselves ({{$node_ip}})
    {{else if ne "" $onode_ip}}protocol bgp SubnetReflectorClient_{{$id}} from bgp_template {
      neighbor {{$onode_ip}} as {{if exists $onode_as_key}}{{getv $onode_as_key}}{{else}}{{getv "/global/as_num"}}{{end}};
      source address {{$node_ip}};
      next hop keep;
    }{{end}}{{end}}
    {{end}}

    # ------------- Global peers -------------
    {{if ls "/global/peer_v4"}}
    {{range gets "/global/peer_v4/*"}}{{$data := json .Value}}
    {{$nums := split $data.ip "."}}{{$id := join $nums "_"}}
    # For peer {{.Key}}
    {{if eq $data.ip $node_ip}} # Skipping ourselves {{$node_ip}}
    {{else}}protocol bgp Global_{{$id}} from bgp_template {
      neighbor {{$data.ip}} as {{$data.as_num}};
      source address {{$node_ip}};  # The local address we use for the TCP connection
    }{{end}}
    {{end}}
    {{else}}# No global peers configured.{{end}}


    # ------------- Node-specific peers -------------
    {{$node_peers_key := printf "/host/%s/peer_v4" (getenv "NODENAME")}}
    {{if ls $node_peers_key}}
    {{range gets (printf "%s/*" $node_peers_key)}}{{$data := json .Value}}
    {{$nums := split $data.ip "."}}{{$id := join $nums "_"}}
    # For peer {{.Key}}
    protocol bgp Node_{{$id}} from bgp_template {
      neighbor {{$data.ip}} as {{$data.as_num}};
      source address {{$node_ip}};  # The local address we use for the TCP connection
    }
    {{end}}
    {{else}}# No node-specific peers configured.{{end}}
  bird.toml.template: |
    [template]
    src = "bird.cfg.no-mesh.template"
    dest = "/etc/calico/confd/config/bird.cfg"
    prefix = "/calico/bgp/v1"
    keys = [
        "/host/{{getenv "NODENAME"}}",
        "/global",
        "/reflector/host",
        "/subnet/host",
        "/subnet/reflector/host",
    ]
    check_cmd = "bird -p -c {{"{{"}}.src{{"}}"}}"
    reload_cmd = "pkill -HUP bird || true"
  bird_aggr.cfg.template: |
    # Generated by confd
    # ------------- Static black hole addresses -------------
    {{if ls "/"}}
    protocol static {
    {{range ls "/"}}
    {{$parts := split . "-"}}
    {{$cidr := join $parts "/"}}
       route {{$cidr}} blackhole;
    {{end}}
    }
    {{else}}# No static routes configured.{{end}}

    # Aggregation of routes on this host; export the block, nothing beneath it.
    function calico_aggr ()
    {
    {{range ls "/"}}
    {{$parts := split . "-"}}
    {{$cidr := join $parts "/"}}
      if ( net = {{$cidr}} ) then { accept; }
      if ( net ~ {{$cidr}} ) then { reject; }
    {{end}}
    }
  bird_aggr.toml.template: |
    [template]
    src = "bird_aggr.cfg.template"
    dest = "/etc/calico/confd/config/bird_aggr.cfg"
    prefix = "/calico/ipam/v2/host/NODENAME/ipv4/block"
    keys = [
        "/",
    ]
    reload_cmd = "pkill -HUP bird || true"
  bird_ipam.cfg.template: |
    # Generated by confd
    filter calico_pools {
      calico_aggr();
      custom_filters();
    {{range ls "/v1/ipam/v4/pool"}}{{$data := json (getv (printf "/v1/ipam/v4/pool/%s" .))}}
      if ( net ~ {{$data.cidr}} ) then {
        accept;
      }
    {{end}}
      reject;
    }

    {{$network_key := printf "/bgp/v1/host/%s/network_v4" (getenv "NODENAME")}}{{$network := getv $network_key}}
    filter calico_ipip
    ip next_hop_ip;
    {
    {{range ls "/v1/ipam/v4/pool"}}{{$data := json (getv (printf "/v1/ipam/v4/pool/%s" .))}}
      if ( net ~ {{$data.cidr}} ) then {
    {{if $data.ipip_mode}}{{if eq $data.ipip_mode "cross-subnet"}}
        if ( defined( bgp_next_hop) ) then {
          next_hop_ip = bgp_next_hop;
        }else{
          next_hop_ip = gw;
        }
        if ( next_hop_ip ~ {{$network}} ) then
          krt_tunnel = "";                     {{/* Destination in ipPool, mode is cross sub-net, route from-host on subnet, do not use IPIP */}}
        else
          krt_tunnel = "{{$data.ipip}}";       {{/* Destination in ipPool, mode is cross sub-net, route from-host off subnet, set the tunnel (if IPIP not enabled, value will be "") */}}
        accept;
      } {{else}}
        krt_tunnel = "{{$data.ipip}}";         {{/* Destination in ipPool, mode not cross sub-net, set the tunnel (if IPIP not enabled, value will be "") */}}
        accept;
      } {{end}} {{else}}
        krt_tunnel = "{{$data.ipip}}";         {{/* Destination in ipPool, mode field is not present, set the tunnel (if IPIP not enabled, value will be "") */}}
        accept;
      } {{end}}
    {{end}}
      accept;                                  {{/* Destination is not in any ipPool, accept  */}}
    }
  bird_ipam.toml.template: |
    [template]
    src = "bird_ipam.cfg.template"
    dest = "/etc/calico/confd/config/bird_ipam.cfg"
    prefix = "/calico"
    keys = [
        "/v1/ipam/v4/pool",
        "/bgp/v1/host/NODENAME"
    ]
    reload_cmd = "pkill -HUP bird || true"
  bird6.cfg.mesh.template: |
    # Generated by confd
    include "bird6_aggr.cfg";
    include "custom_filters6.cfg";
    include "bird6_ipam.cfg";
    {{$node_ip_key := printf "/host/%s/ip_addr_v4" (getenv "NODENAME")}}{{$node_ip := getv $node_ip_key}}
    {{$node_ip6_key := printf "/host/%s/ip_addr_v6" (getenv "NODENAME")}}{{$node_ip6 := getv $node_ip6_key}}

    router id {{$node_ip}};  # Use IPv4 address since router id is 4 octets, even in MP-BGP

    {{define "LOGGING"}}
    {{$node_logging_key := printf "/host/%s/loglevel" (getenv "NODENAME")}}{{if exists $node_logging_key}}{{$logging := getv $node_logging_key}}
    {{if eq $logging "debug"}}  debug all;{{else if ne $logging "none"}}  debug { states };{{end}}
    {{else if exists "/global/loglevel"}}{{$logging := getv "/global/loglevel"}}
    {{if eq $logging "debug"}}  debug all;{{else if ne $logging "none"}}  debug { states };{{end}}
    {{else}}  debug { states };{{end}}
    {{end}}

    # Configure synchronization between routing tables and kernel.
    protocol kernel {
      learn;             # Learn all alien routes from the kernel
      persist;           # Don't remove routes on bird shutdown
      scan time 2;       # Scan kernel routing table every 2 seconds
      import all;
      export all;        # Default is export none
      graceful restart;  # Turn on graceful restart to reduce potential flaps in
                         # routes when reloading BIRD configuration.  With a full
                         # automatic mesh, there is no way to prevent BGP from
                         # flapping since multiple nodes update their BGP
                         # configuration at the same time, GR is not guaranteed to
                         # work correctly in this scenario.
    }

    # Watch interface up/down events.
    protocol device {
      {{template "LOGGING"}}
      scan time 2;    # Scan interfaces every 2 seconds
    }

    protocol direct {
      {{template "LOGGING"}}
      interface -"cali*", "*"; # Exclude cali* but include everything else.
    }

    {{if eq "" ($node_ip6)}}# IPv6 disabled on this node.
    {{else}}{{$node_as_key := printf "/host/%s/as_num" (getenv "NODENAME")}}
    # Template for all BGP clients
    template bgp bgp_template {
      {{template "LOGGING"}}
      description "Connection to BGP peer";
      local as {{if exists $node_as_key}}{{getv $node_as_key}}{{else}}{{getv "/global/as_num"}}{{end}};
      multihop;
      gateway recursive; # This should be the default, but just in case.
      import all;        # Import all routes, since we don't know what the upstream
                         # topology is and therefore have to trust the ToR/RR.
      export filter calico_pools;  # Only want to export routes for workloads.
      next hop self;     # Disable next hop processing and always advertise our
                         # local address as nexthop
      source address {{$node_ip6}};  # The local address we use for the TCP connection
      add paths on;
      graceful restart;  # See comment in kernel section about graceful restart.
    }

    # ------------- Node-to-node mesh -------------
    {{if (json (getv "/global/node_mesh")).enabled}}
    {{range $host := lsdir "/host"}}
    {{$onode_as_key := printf "/host/%s/as_num" .}}
    {{$onode_ip_key := printf "/host/%s/ip_addr_v6" .}}{{if exists $onode_ip_key}}{{$onode_ip := getv $onode_ip_key}}
    {{$nums := split $onode_ip ":"}}{{$id := join $nums "_"}}
    # For peer {{$onode_ip_key}}
    {{if eq $onode_ip ($node_ip6) }}# Skipping ourselves ({{$node_ip6}})
    {{else if eq "" $onode_ip}}# No IPv6 address configured for this node
    {{else}}protocol bgp Mesh_{{$id}} from bgp_template {
      neighbor {{$onode_ip}} as {{if exists $onode_as_key}}{{getv $onode_as_key}}{{else}}{{getv "/global/as_num"}}{{end}};
    }{{end}}{{end}}{{end}}
    {{else}}
    # Node-to-node mesh disabled
    {{end}}


    # ------------- Global peers -------------
    {{if ls "/global/peer_v6"}}
    {{range gets "/global/peer_v6/*"}}{{$data := json .Value}}
    {{$nums := split $data.ip ":"}}{{$id := join $nums "_"}}
    # For peer {{.Key}}
    protocol bgp Global_{{$id}} from bgp_template {
      neighbor {{$data.ip}} as {{$data.as_num}};
    }
    {{end}}
    {{else}}# No global peers configured.{{end}}


    # ------------- Node-specific peers -------------
    {{$node_peers_key := printf "/host/%s/peer_v6" (getenv "NODENAME")}}
    {{if ls $node_peers_key}}
    {{range gets (printf "%s/*" $node_peers_key)}}{{$data := json .Value}}
    {{$nums := split $data.ip ":"}}{{$id := join $nums "_"}}
    # For peer {{.Key}}
    protocol bgp Node_{{$id}} from bgp_template {
      neighbor {{$data.ip}} as {{$data.as_num}};
    }
    {{end}}
    {{else}}# No node-specific peers configured.{{end}}
    {{end}}
  bird6.cfg.no-mesh.template: |
    # Generated by confd
    include "bird6_aggr.cfg";
    include "custom_filters6.cfg";
    include "bird6_ipam.cfg";
    {{$node_ip_key := printf "/host/%s/ip_addr_v4" (getenv "NODENAME")}}{{$node_ip := getv $node_ip_key}}
    {{$node_ip6_key := printf "/host/%s/ip_addr_v6" (getenv "NODENAME")}}{{$node_ip6 := getv $node_ip6_key}}

    router id {{$node_ip}};  # Use IPv4 address since router id is 4 octets, even in MP-BGP

    {{define "LOGGING"}}
    {{$node_logging_key := printf "/host/%s/loglevel" (getenv "NODENAME")}}{{if exists $node_logging_key}}{{$logging := getv $node_logging_key}}
    {{if eq $logging "debug"}}  debug all;{{else if ne $logging "none"}}  debug { states };{{end}}
    {{else if exists "/global/loglevel"}}{{$logging := getv "/global/loglevel"}}
    {{if eq $logging "debug"}}  debug all;{{else if ne $logging "none"}}  debug { states };{{end}}
    {{else}}  debug { states };{{end}}
    {{end}}

    # Configure synchronization between routing tables and kernel.
    protocol kernel {
      learn;             # Learn all alien routes from the kernel
      persist;           # Don't remove routes on bird shutdown
      scan time 2;       # Scan kernel routing table every 2 seconds
      import all;
      export all;        # Default is export none
      graceful restart;  # Turn on graceful restart to reduce potential flaps in
                         # routes when reloading BIRD configuration.  With a full
                         # automatic mesh, there is no way to prevent BGP from
                         # flapping since multiple nodes update their BGP
                         # configuration at the same time, GR is not guaranteed to
                         # work correctly in this scenario.
    }

    # Watch interface up/down events.
    protocol device {
      {{template "LOGGING"}}
      scan time 2;    # Scan interfaces every 2 seconds
    }

    protocol direct {
      {{template "LOGGING"}}
      interface -"cali*", "*"; # Exclude cali* but include everything else.
    }

    {{if eq "" ($node_ip6)}}# IPv6 disabled on this node.
    {{else}}{{$node_as_key := printf "/host/%s/as_num" (getenv "NODENAME")}}
    # Template for all BGP clients
    template bgp bgp_template {
      {{template "LOGGING"}}
      description "Connection to BGP peer";
      local as {{if exists $node_as_key}}{{getv $node_as_key}}{{else}}{{getv "/global/as_num"}}{{end}};
      multihop;
      gateway recursive; # This should be the default, but just in case.
      import all;        # Import all routes, since we don't know what the upstream
                         # topology is and therefore have to trust the ToR/RR.
      export filter calico_pools;  # Only want to export routes for workloads.
      next hop self;     # Disable next hop processing and always advertise our
                         # local address as nexthop
      source address {{$node_ip6}};  # The local address we use for the TCP connection
      add paths on;
      graceful restart;  # See comment in kernel section about graceful restart.
    }


    # ------------- Global peers -------------
    {{if ls "/global/peer_v6"}}
    {{range gets "/global/peer_v6/*"}}{{$data := json .Value}}
    {{$nums := split $data.ip ":"}}{{$id := join $nums "_"}}
    # For peer {{.Key}}
    protocol bgp Global_{{$id}} from bgp_template {
      neighbor {{$data.ip}} as {{$data.as_num}};
    }
    {{end}}
    {{else}}# No global peers configured.{{end}}


    # ------------- Node-specific peers -------------
    {{$node_peers_key := printf "/host/%s/peer_v6" (getenv "NODENAME")}}
    {{if ls $node_peers_key}}
    {{range gets (printf "%s/*" $node_peers_key)}}{{$data := json .Value}}
    {{$nums := split $data.ip ":"}}{{$id := join $nums "_"}}
    # For peer {{.Key}}
    protocol bgp Node_{{$id}} from bgp_template {
      neighbor {{$data.ip}} as {{$data.as_num}};
    }
    {{end}}
    {{else}}# No node-specific peers configured.{{end}}
    {{end}}
  bird6.toml.template: |
    [template]
    src = "bird6.cfg.{{if (json (getv "/node_mesh")).enabled}}mesh{{else}}no-mesh{{end}}.template"
    dest = "/etc/calico/confd/config/bird6.cfg"
    prefix = "/calico/bgp/v1"
    keys = [
        {{if (json (getv "/node_mesh")).enabled}}"/host"{{else}}"/host/{{getenv "NODENAME"}}"{{end}},
        "/global"
    ]
    check_cmd = "bird6 -p -c {{"{{"}}.src{{"}}"}}"
    reload_cmd = "pkill -HUP bird6 || true"
  bird6_aggr.toml.template: |
    [template]
    src = "bird_aggr.cfg.template"
    dest = "/etc/calico/confd/config/bird6_aggr.cfg"
    prefix = "/calico/ipam/v2/host/NODENAME/ipv6/block"
    keys = [
        "/",
    ]
    reload_cmd = "pkill -HUP bird || true"
  bird6_ipam.cfg.template: |
    # Generated by confd
    filter calico_pools {
      calico_aggr();
      custom_filters();
    {{range ls "/pool"}}{{$data := json (getv (printf "/pool/%s" .))}}
      if ( net ~ {{$data.cidr}} ) then {
        accept;
      }
    {{end}}
      reject;
    }
  custom_filters.cfg.template: |
    # Generated by confd
    function custom_filters ()
    {
    {{range ls "/v4"}}{{$data := getv (printf "/v4/%s" .)}}
    {{ $data }}
    {{end}}
    }
  custom_filters6.cfg.template: |
    # Generated by confd
    function custom_filters ()
    {
    {{range ls "/v6"}}{{$data := getv (printf "/v6/%s" .)}}
    {{ $data }}
    {{end}}
    }
  git-version: 1a55c2e7d1cf79608395c86c46d6a7da48f6e47f
  tunl-ip.template: "We must dump all pool data to this file to trigger a resync.\nOtherwise,
    confd notices the file hasn't changed and won't\nrun our python update script.\n
    \n{{range ls \"/pool\"}}{{$data := json (getv (printf \"/pool/%s\" .))}}\n  {{if
    $data.ipip}}{{if not $data.disabled}}{{$data.cidr}}{{end}}{{end}}\n{{end}}\n"
kind: ConfigMap
metadata:
  name: calico-bird-templates
  namespace: kube-system
